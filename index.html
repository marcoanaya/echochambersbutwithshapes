<head>
  <meta charset="UTF-8">
  <meta name="description" content="this is a website about echo chambers but with shapes.">
  <meta name="keywords" content="trianges, squares, hexagons, circles">
  <meta name="author" content="Marco Anaya">
  <meta name="title" content="echo chambers but with shapes">
  <meta property="og:title" content="hello">
  <meta property="og:description" content="this is a website about echo chambers but with shapes.">
  <meta property="og:image" content="http://euro-travel-example.com/thumbnail.jpg">
</head>

<div>
  
</div>
<script src="https://cdn.jsdelivr.net/npm/p5@1.2.0/lib/p5.js"></script>

<script>
  // converts 'polarity' coefficient to color
  // todo: red and blue are a little on the nose but they were the easiest
  const clr = c => [128+c, 50, 128-c];
  // function to calculate max signal size based on polarity coefficient
  const maxSigSize = c => (2*Math.abs(c));
  // javascript doesn't have good random functions :^(
  const rand_within = (x, delta) => random(x-delta, x+delta);
  // increases x by i, but rounds to 'cap'
  const increment = (x, i, cap) => (
    (Math.abs(x + i) > Math.abs(cap))
      ? Math.sign(x + i) * cap 
      : x + i
  )

  /* Node class
   * Represents each individual shape
   */
  class Node {
    constructor(i, w, h, g) {
      this.name = i;
      this.graph = g;
      // polarity coefficient
      this.c = random(-100, 100);
      this.color = clr(this.c);
      
      // random attributes for more visual aesthetics
      // todo: make shapes more interesting
      this.r = Math.random();
      [this.x, this.y] = [w, h].map(x => random(-x/3, x/3));
      this.sides = random([3,4,6,24])
      this.radii = [25,15].map(x => rand_within(x, x/5))
      
      // initializes 'signal' (circle that comes out of shape)
      this.signalSize = 0;
    }
    /* graphic representation of shape and its 'signal' */
    draw(fc) {
      push();
      translate(this.x, this.y);
      this.drawSelf(fc);
      this.drawSignal(fc);
      pop();
    }
    drawSelf(fc) {
      push();
      fill(...clr(this.c));
      noStroke();
      [rotateX, rotateY].map(f => f((this.r * fc)/10));
      torus(...this.radii, this.sides);
      pop();
    }
    drawSignal(fc) {
      push();
      fill(...clr(this.c));
      stroke(...clr(this.c));    
      rotateX(PI/2);
      rotateY(0);
      cylinder(this.signalSize, 10, 24, 1, false, false );
      pop();
    }
    /* updates the shapes position, and other attributes 
       (randomly or predetermined) */
    update(d) {
      this.updateSignal()
      this.c = increment(this.c, random(-5, 5), 128);
      this.x += random(-1, 1);
      this.y += random(-1, 1);
    }
    /* increases signal size and sets to zero when it has reached its max size
       at that point, 'influences' all the shapes the signal reached*/
    updateSignal() {
      if (this.signalSize > maxSigSize(this.c)) {
        this.graph.updateDist(this.name);
        this.signalSize = 0;
      } else if (this.signalSize > 0) {
        this.signalSize += 5;
      }
    }
    /* distance formula */
    dist(that) {
      return Math.sqrt(Math.pow(this.x-that.x,2) + Math.pow(this.y-that.y,2));
    }
    /* 'influences' another shape by updating its attributes*/
    /* todo: tweak */
    influence(that) {
      let sign = (Math.sign(this.c) === Math.sign(that.c))
      // 1 if are similar polarity, -1 if opposite
      let dir = Math.sign(sign - 0.5);
      // moves closer if similar polarity, father apart if opposite
      that.x += dir * Math.sign(this.x-that.x) * 5;
      that.y += dir * Math.sign(this.y-that.y) * 5;
      // increases polarity if similar, does nothing if opposite
      that.c = increment(that.c, sign * Math.sign(this.c), 128);    
    }
  }
  
  /* Graph class
   * Represents a collection of shapes and updates based on their interactions
   */
  class Graph {
    constructor(n, w, h) {
      this.n = n;
      this.nodes = Array(n)
        .fill()
        .map((_, i) => new Node(i, w, h, this));
    }
    /* when a nodes signal has been sent, this function updates the 
       shapes it has reached */
    updateDist(i) {
      let n1 = this.nodes[i];
      this.nodes.map((n2, j) => {
        if ((i !== j) && (n1.dist(n2) <= maxSigSize(n1.c)))
          n1.influence(n2);
      });
    }
    /* continually draws and updates nodes, 
       sends signal as previous signal is done */
    run() {
      this.nodes.map((n, i) => {
        n.update(deltaTime);
        n.draw(frameCount);
        // todo: a little sloppy
        if (i === (frameCount % this.nodes.length) && (n.signalSize === 0)) {
          n.signalSize=1;
        }  
      });
    }
  }

  // p5.js stuff
  let g;
  
  setup = () => {
    frameRate(30); 
    createCanvas(windowWidth, windowHeight, WEBGL)
    g = new Graph(20, windowWidth, windowHeight);
  }
  draw = () => {
    background(20)
    g.run();
  }
</script>