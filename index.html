
<div>
  
</div>
<script src="https://cdn.jsdelivr.net/npm/p5@1.2.0/lib/p5.js"></script>

<script>
  // converts 'polarity' coefficient to color
  // todo: red and blue are a little on the nose but they were the easiest
  const clr = c => [128+c, 50, 128-c];
  // function to calculate max signal size based on polarity coefficient
  const maxSigSize = c => (2*Math.abs(c));
  // javascript doesn't have good random functions :^(
  const rand_between = (s, e) => (Math.random() * (e-s)) + s;
  const rand_arr = arr => arr[Math.floor(rand_between(0, arr.length))];
  const rand_within = (x, delta) => rand_between(x-delta, x+delta);
  // increases x by i, but rounds to 'cap'
  const increment = (x, i, cap) => (
    (Math.abs(x + i) > Math.abs(cap))
      ? Math.sign(x + i) * cap 
      : x + i
  )

  /* Node class
   * Represents each individual shape
   */
  class Node {
    constructor(i, w, h, g) {
      this.name = i;
      this.graph = g;
      // polarity coefficient
      this.c = rand_between(-100, 100);
      this.color = clr(this.c);
      
      // random attributes for more visual aesthetics
      // todo: make shapes more interesting
      this.r = Math.random();
      [this.x, this.y] = [w, h].map(x => rand_between(-x/3, x/3));
      this.sides = rand_arr([3,4,6,24])
      this.radii = [25,15].map(x => rand_within(x, x/5))
      
      // initializes 'signal' (circle that comes out of shape)
      this.signalSize = 0;
    }
    /* graphic representation of shape and its 'signal' */
    draw(fc) {
      push();
      translate(this.x, this.y);
      this.drawSelf(fc);
      this.drawSignal(fc);
      pop();
    }
    drawSelf(fc) {
      push();
      fill(...clr(this.c));
      noStroke();
      [rotateX, rotateY].map(f => f((this.r * fc)/10));
      torus(...this.radii, this.sides);
      pop();
    }
    drawSignal(fc) {
      push();
      fill(...clr(this.c));
      stroke(...clr(this.c));    
      rotateX(PI/2);
      rotateY(0);
      cylinder(this.signalSize, 10, 24, 1, false, false );
      pop();
    }
    /* updates the shapes position, and other attributes 
       (randomly or predetermined) */
    update(d) {
      this.updateSignal()
      this.c = increment(this.c, rand_between(-5, 5), 128);
      this.x += rand_between(-1, 1);
      this.y += rand_between(-1, 1);
    }
    /* increases signal size and sets to zero when it has reached its max size
       at that point, 'influences' all the shapes the signal reached*/
    updateSignal() {
      if (this.signalSize > maxSigSize(this.c)) {
        this.graph.updateDist(this.name);
        this.signalSize = 0;
      } else if (this.signalSize > 0) {
        this.signalSize += 5;
      }
    }
    /* distance formula */
    dist(that) {
      return Math.sqrt(Math.pow(this.x-that.x,2) + Math.pow(this.y-that.y,2));
    }
    /* 'influences' another shape by updating its attributes*/
    /* todo: tweak */
    influence(that) {
      let sign = (Math.sign(this.c) === Math.sign(that.c))
      // 1 if are similar polarity, -1 if opposite
      let dir = Math.sign(sign - 0.5);
      // moves closer if similar polarity, father apart if opposite
      that.x += dir * Math.sign(this.x-that.x) * 5;
      that.y += dir * Math.sign(this.y-that.y) * 5;
      // increases polarity if similar, does nothing if opposite
      that.c = increment(that.c, sign * Math.sign(this.c), 128);    
    }
  }
  
  /* Graph class
   * Represents a collection of shapes and updates based on their interactions
   */
  class Graph {
    constructor(n, w, h) {
      this.n = n;
      this.nodes = Array(n)
        .fill()
        .map((_, i) => new Node(i, w, h, this));
    }
    /* */
    updateDist(i) {
      let n1 = this.nodes[i];
      this.nodes.map((n2, j) => {
        if (i === j) return;
        if (n1.dist(n2) <= maxSigSize(n1.c)) {
          n1.influence(n2);
        }
      })
      
    }
    /* continually draws and updates nodes, 
       sends signal as previous signal is done */
    run() {
      this.nodes.map((n, i) => {
        n.update(deltaTime);
        n.draw(frameCount);
        // todo: a little sloppy
        if (i === (frameCount % this.nodes.length) && (n.signalSize === 0)) {
          n.signalSize=1;
        }
        
    })
    }
  }

  // p5.js stuff
  let g;
  
  setup = () => {
    frameRate(30); 
    createCanvas(windowWidth, windowHeight, WEBGL)
    g = new Graph(20, windowWidth, windowHeight);
  }
  draw = () => {
    background(20)
    g.run();
  }
</script>